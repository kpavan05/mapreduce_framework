#ifndef _WORKER_H
#define _WORKER_H

#include <Python.h>
#include <iostream>
#include <memory>
#include <string>
#include <vector>
#include <exception>
#include <glog/logging.h>

#include <was/storage_account.h>
#include <was/blob.h>
#include <cpprest/filestream.h>
#include <cpprest/containerstream.h>

#define EXTRA_LEN 16
#define BUFFLEN 512



class WorkerDBConnection
{
  public:
    WorkerDBConnection(const std::string & conn, const std::string & name)
    {
      m_connection = conn;
      m_mstrcontainername = name;
      init();
    }

    std::string get_worker_containername()
    {
      return m_wrkrcontainername ;
    }

    // write the shard data to local temp file
    bool write_partial_data_to_local_file(std::string blobname, size_t begin, size_t end, std::string address, std::string & outfile_name)
    {
        try {
          LOG(INFO)<< "getting shard offset:" << begin << " with blob name " << blobname;

          auto block_blob = m_mstrcontainer.get_block_blob_reference(blobname);
          concurrency::streams::container_buffer<std::vector<uint8_t>> buffer;

          concurrency::streams::ostream out_stream(buffer);
          size_t len = (end- begin ) + EXTRA_LEN;
          block_blob.download_range_to_stream(out_stream, begin, len);
          LOG(INFO) << "downloaded shard offset:" << begin;

          fix_word_boundary(begin, end, buffer.collection());
          LOG(INFO) << "fixed word boundary shard offset:" << begin;
          size_t len_downloaded = buffer.collection().size();

          outfile_name= "sh-"+std::to_string(begin)+"-"+std::to_string(end) + "-" + address;
          std::ofstream out_file(outfile_name, std::ofstream::binary);
          out_file.write(reinterpret_cast<char *>(buffer.collection().data()), len_downloaded);
          out_file.close();
          out_stream.close().wait();
          LOG(INFO) << "done writing local copy "<< outfile_name << " for shard offset:" << begin << " and len:" << (end -begin);
          return true;
        }
        catch (exception e)
        {
            return false;
        }
    }
    // write the intermediate blob data into local temp file
    bool write_full_data_to_local_file1(std::string blob, std::string containername, std::string address, std::string & outfile_name)
    {
        try
        {
          auto container = m_blob_client.get_container_reference(containername);
          container.create_if_not_exists();

          auto append_blob = container.get_append_blob_reference(blob);
          concurrency::streams::container_buffer<std::vector<uint8_t>> buffer;

          concurrency::streams::ostream out_stream(buffer);

          append_blob.download_to_stream(out_stream);
          size_t len_downloaded = buffer.collection().size();
          outfile_name= "kv-" + address;
          std::ofstream out_file(outfile_name, std::ofstream::binary);
          out_file.write(reinterpret_cast<char *>(buffer.collection().data()), len_downloaded);
          out_file.close();
          out_stream.close().wait();
          LOG(INFO) << "done writing local copy "<< outfile_name;
          return true;
        }
        catch (exception e)
        {
            return false;
        }
    }

    // write the intermediate blob data into local temp file
    bool write_full_data_to_local_file(std::string containername, std::string blob, std::string address, std::ofstream &tmp_file)
    {
        try
        {
          auto container = m_blob_client.get_container_reference(containername);
          container.create_if_not_exists();

          auto block_blob = container.get_block_blob_reference(blob);
          concurrency::streams::container_buffer<std::vector<uint8_t>> buffer;

          concurrency::streams::ostream out_stream(buffer);

          block_blob.download_to_stream(out_stream);
          size_t len_downloaded = buffer.collection().size();

          LOG(INFO) << "writing temporary local copy ";
          //std::ofstream out_file;
          //out_file.open(outfile_name, std::ios_base::app | std::ios::binary);
          //std::ofstream out_file(outfile_name, std::ofstream::binary);
          tmp_file.write(reinterpret_cast<char *>(buffer.collection().data()), len_downloaded);
          //tm_file.close();
          //out_stream.close().wait();
          LOG(INFO) << "done writing temporary local copy ";
          return true;
        }
        catch (exception e)
        {
            return false;
        }
    }
    // create append blob inside 'int' container
    void append_to_blob(int blob_id)
    {
      std::string outfile_name = "int_" + std::to_string(blob_id);
      auto blob = m_wrkrcontainer.get_append_blob_reference(outfile_name);
      LOG(INFO) <<"append blob created ";
      concurrency::streams::istream input_stream = concurrency::streams::file_stream<uint8_t>::open_istream(outfile_name).get();
      blob .upload_from_stream(input_stream);
      LOG(INFO) <<"uploading from "<< outfile_name << " stream done ";
      input_stream.close().wait();
    }

    // create block blob inside 'int' container
    void add_intermediate_blob(int blob_id, std::string address, int sid, std::string & containername, std::vector<std::string>& bloblst)
    {
      containername = m_wrkrcontainername;
      std::string blobname;
      blobname.clear();
      blobname = "int_" ; blobname += address ; blobname += '_' ;
      blobname += std::to_string(sid) ; blobname += '_' ; blobname += std::to_string(blob_id);


      auto block_blob = m_wrkrcontainer.get_block_blob_reference(blobname);
      LOG(INFO) <<"block blob created " << blobname;
      concurrency::streams::istream input_stream = concurrency::streams::file_stream<uint8_t>::open_istream(blobname).get();
      block_blob.upload_from_stream(input_stream);
      LOG(INFO) <<"uploading from "<< blobname << " stream done ";
      input_stream.close().wait();
      bloblst.push_back(blobname);
    }

    // create 'out' container and a blob 'out_<wrkr address>
    void add_out_blob(std::string outfile_name, std::string & blob, std::string & containername)
    {
      containername = m_mstrcontainername + "out";
      auto container = m_blob_client.get_container_reference(containername);
      container.create_if_not_exists();

      blob = outfile_name;
      auto block_blob = container.get_block_blob_reference(blob);
      LOG(INFO) << "block blob created " << blob;

      concurrency::streams::istream input_stream = concurrency::streams::file_stream<uint8_t>::open_istream(outfile_name).get();
<<<<<<< HEAD
      block_blob.upload_from_stream(input_stream);
      LOG(INFO) <<"uploading from "<< outfile_name << " stream done ";
||||||| 1781ab8
      block_blob .upload_from_stream(input_stream);
      LOG(INFO) <<"uploading from "<< outfile_name << " stream done ";
=======
      block_blob.upload_from_stream(input_stream);
      LOG(INFO) << "uploading from " << outfile_name << " stream done ";
>>>>>>> f4e75620fc8bc4369471ad84cd20450aaadced7b
      input_stream.close().wait();
    }

  private:

    void fix_word_boundary(size_t begin, size_t end, std::vector<uint8_t> & collection)
    {
      if (begin != 0)
      {
          int i = 0;
          while (i < EXTRA_LEN)
          {
              char c = collection.at(i);
              if (c == ' ' || c == '.' || c ==',') break;
              collection[i] = ' ';
              i++;
          }

      }
      int endpos = end - begin;
      int eofpos = collection.size();
      if (eofpos > endpos)
      {
          LOG(INFO) << "fixed the end of the shard ";
          int i = endpos;
          while (i < collection.size())
          {
              char c = collection.at(i);
              if (c == ' ' || c == '.' || c ==',') break;
              i++;
          }

          collection.erase(collection.begin() + i, collection.end());
          add_suffix(collection);

      }
      else
      {
          add_suffix(collection);

      }
    }
    void add_suffix(std::vector<uint8_t> & collection)
    {

        collection.push_back(' ');
        collection.push_back('g');
        collection.push_back('a');
        collection.push_back('t');
        collection.push_back('e');
        collection.push_back('c');
        collection.push_back('h');
    }

    void init ()
    {
      try
      {
        auto st_account = azure::storage::cloud_storage_account::parse(m_connection);
        LOG(INFO) << "mr19 storage account connected";

        m_blob_client = st_account.create_cloud_blob_client();
        LOG(INFO) << "blob client is created";

        m_mstrcontainer = m_blob_client.get_container_reference(m_mstrcontainername);
        m_mstrcontainer.create_if_not_exists();

        m_wrkrcontainername = m_mstrcontainername + "int";
        LOG(INFO) << "creating container "<< m_wrkrcontainername << " with blob client";
        m_wrkrcontainer = m_blob_client.get_container_reference(m_wrkrcontainername);
        m_wrkrcontainer.create_if_not_exists();
        LOG(INFO) << "created container "<< m_wrkrcontainername << " with blob client";
      }
      catch (const azure::storage::storage_exception& e)
      {
          ucout << U("Error: ") << e.what() << std::endl;

          azure::storage::request_result result = e.result();
          azure::storage::storage_extended_error extended_error = result.extended_error();
          if (!extended_error.message().empty())
          {
              ucout << extended_error.message() << std::endl;
          }
      }
      catch (exception e)
      {
        LOG(INFO) << "exception thrown " << e.what();
      }

    }

  private:

    std::string m_connection;
    std::string m_mstrcontainername;
    std::string m_wrkrcontainername;
    azure::storage::cloud_blob_client m_blob_client;
    azure::storage::cloud_blob_container m_mstrcontainer;
    azure::storage::cloud_blob_container m_wrkrcontainer;
};








class Worker
{
  public:
    Worker(std::string & address)
    {
      std::cout << "instantiating worker " << address << std::endl;
      m_address = address;
      m_nreducers = 0;

      m_dbConnection = nullptr;
      Py_Initialize();
      PyRun_SimpleString("import sys");
      PyRun_SimpleString("sys.path.append(\".\")");
    }

    ~Worker()
    {
      Py_FinalizeEx();
    }

    std::string get_address() { return m_address; }
    std::string get_intermediate_container()
    {
      return m_dbConnection->get_worker_containername();
    }

    void create_connection(const std::string & connString, const std::string & containerName)
    {
      m_dbConnection = new WorkerDBConnection(connString, containerName);
    }

    bool map_shard(std::string blobname, size_t begin, size_t end, int nReducers, int sid, std::string & out_container, std::vector<std::string> &bloblst)
    {
      std::string outfile;

      m_nreducers = nReducers;
      // create streams for local intermediate files
      create_r_intermediate_files(sid);
      // write blob data to temp file on disk
      m_dbConnection->write_partial_data_to_local_file(blobname, begin, end, m_address, outfile);
      LOG(INFO) << " mapper will run on the file " << outfile;
      // run user defined map function and stream to intermediate file
      // call_py(outfile, true);
      instantiate_map_function(outfile);
      // close intermediate file streams
      close_r_intermediate_files();
      // write intermediate file to append blob
      //append_intermediate_file_to_blob();

      add_intermediate_file_to_blob(sid, out_container, bloblst);
      return true;
    }

    void prepare_data(std::string in_container, std::string in_blob, std::ofstream & tmp_file)
    {
      // write blob data to temp file on disk
      m_dbConnection->write_full_data_to_local_file(in_container, in_blob, m_address, tmp_file);
    }
    bool reduce(std::string in_container, std::string outfile, std::string & out_blob, std::string & out_container)
    {
      out_blob.clear();
      out_container.clear();

      // create stream for output
      create_output_file();
      // write blob data to temp file on disk
      //m_dbConnection->write_full_data_to_local_file(in_blob, in_container, m_address, outfile);
      LOG(INFO) << " reducer will run on the file " << outfile;
      // run user defined reduce function and stream to output stream
      instantiate_reduce_function(outfile);
      // close the output stream
      close_output_file();
      // write the final data in output stream to final blob
      add_out_file_to_blob(out_blob, out_container);

      return true;
    }

  private:
    void instantiate_map_function(std::string fname)
    {
      LOG(INFO)<<"instantiating map python script";
      instantiate_py_func("map" , "mapfunc", fname);
    }

    void instantiate_reduce_function(std::string fname)
    {
      LOG(INFO)<<"instantiating reduce python script";
      instantiate_py_func("reduce", "reducefunc", fname);
    }

    void instantiate_py_func(std::string script, std::string funcname, std::string filename)
    {
      PyObject *pName, *pModule;
      PyObject *pFunc;
      bool ismap = false;
      if (script.compare("map") == 0)
      {
        ismap = true;
      }
      pName = PyUnicode_DecodeFSDefault(script.c_str());
      pModule = PyImport_Import(pName);
      Py_DECREF(pName);
      LOG(INFO) << "import python module " << script;
      if (pModule != NULL)
      {

            pFunc = PyObject_GetAttrString(pModule, funcname.c_str());
            LOG(INFO) << "created python function " << funcname;
            if (!pFunc || !PyCallable_Check(pFunc))
            {

                Py_DECREF(pFunc);
                Py_DECREF(pModule);
                PyErr_Print();
                LOG(INFO) << "Call to python map function failed";
                pFunc = nullptr;
                return;
            }
            else
            {
              PyObject *pArgs, *pValue;
              size_t val = 0;
              pArgs = PyTuple_New(1);


              pValue = PyUnicode_FromString(filename.c_str());
              LOG(INFO) << "assign arguments to script " << filename ;
              if (!pValue)
              {
                  Py_DECREF(pArgs);
                  LOG(INFO) << "Arguments to python script cannot be converted";
                  return;
              }
              PyTuple_SetItem(pArgs, 0, pValue);

              pValue = PyObject_CallObject(pFunc, pArgs);


              Py_DECREF(pArgs);
              if (pValue != NULL)
              {
                LOG(INFO) << "got return value from python function";
                PyObject *key, *value;
                Py_ssize_t pos = 0;

                while (PyDict_Next(pValue, &pos, &key, &value))
                {
                    long ncount = PyLong_AsLong(value);
                    // convert object to string in python3
                    // https://stackoverflow.com/questions/5356773/python-get-string-representation-of-pyobject
                    PyObject* repr = PyObject_Repr(key);
                    PyObject* str = PyUnicode_AsEncodedString(repr, "utf-8", "~E~");
                    const char *word = PyBytes_AS_STRING(str);
                    //LOG(INFO) << " key: " << word << " val:" << ncount << std::endl;
                    stream_to_file(word, ncount, ismap);

                    Py_XDECREF(repr);
                    Py_XDECREF(str);
                }
                LOG(INFO) << "python function call done";
                Py_DECREF(pValue);
              }
              else
              {
                LOG(INFO) << "no return value from python function";
              }
              return;
            }
      }
      else
      {
          PyErr_Print();
          LOG(INFO) << "Cannot find the module in python script";
          return;
      }
    }

    void stream_to_file(const char * word, long val, bool ismap)
    {
      if (ismap)
      {
        std::string s(word);
        int file_num = (std::hash<std::string>{} (s)) % m_nreducers;
        //LOG(INFO) << "streaming to " << file_num << " key: " << word << " val:" << val << std::endl;
        m_inter_files[file_num] << word << ':' << std::to_string(val) <<std::endl;
      }
      else
      {
        //LOG(INFO) << " key: " << word << " val:" << val << std::endl;
        m_outstream << word << ':' << std::to_string(val) << std::endl;
      }
    }

    void create_r_intermediate_files(int sid)
    {

      for (int i = 0; i < m_nreducers; i++)
      {
          std::string iname;
          iname.clear();
          iname = "int_";
          iname += m_address;
          iname += '_';
          iname += std::to_string(sid);
          iname += '_';
          iname += std::to_string(i);

          LOG(INFO) << "creating intermediate file "<< iname;
          m_inter_files.emplace_back(std::ofstream{iname});
      }
    }

    void close_r_intermediate_files()
    {
      LOG(INFO) << "closing intermediate files";
      for (int i = 0; i < m_nreducers; i++)
      {
        m_inter_files[i].close();
      }
      m_inter_files.clear();
    }

    void append_intermediate_file_to_blob()
    {
      LOG(INFO) << "append intermediate file to blob";
      for (int i = 0; i < m_nreducers; i++)
      {
        m_dbConnection->append_to_blob(i);

      }

    }

    void add_intermediate_file_to_blob(int sid, std::string & container, std::vector<std::string> & bloblst)
    {
      LOG(INFO) << "add intermediate file to blob";
      for (int i = 0; i < m_nreducers; i++)
      {

        m_dbConnection->add_intermediate_blob(i, m_address, sid, container, bloblst);

      }

    }

    void create_output_file()
    {
      m_outfile = "out_" + m_address;
      m_outstream.open(m_outfile);
    }

    void close_output_file()
    {
      m_outstream.close();
    }

    void add_out_file_to_blob(std::string &blob, std::string & container)
    {
      m_dbConnection->add_out_blob(m_outfile, blob, container);
    }

  private:
    std::string m_address;
    int m_nreducers;

    WorkerDBConnection  * m_dbConnection;
    PyObject *m_pyMapFunc;
    PyObject *m_pyReduceFunc;

    std::ofstream m_outstream;
    std::string m_outfile;
    std::vector<std::ofstream> m_inter_files;

};

#endif